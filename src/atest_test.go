package direwolf

import (
	"bytes"
	"encoding/binary"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"testing"

	"github.com/spf13/pflag"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// Examples from original atest.c source, using packets generated by Dire Wolf gen_packets until we port that...

func Test_atest_basic_1(t *testing.T) {
	var tmpdir = t.TempDir()

	var f = filepath.Join(tmpdir, "test1.wav")

	var cmd = exec.Command("gen_packets", "-o", f) //nolint:gosec

	var err = cmd.Run()
	if err != nil {
		t.Fail()
	}

	os.Args = []string{"atest", f}

	// Capture stdout
	var oldStdout = os.Stdout

	defer func() {
		os.Stdout = oldStdout
	}()

	var r, w, _ = os.Pipe()

	os.Stdout = w

	// Run
	AtestMain()

	w.Close() //nolint:gosec

	os.Stdout = oldStdout

	var outputBytes, _ = io.ReadAll(r)

	var outputString = string(outputBytes)

	// I don't yet understand it, but somehow this content doesn't turn up if you capture stdout :(
	// assert.Contains(t, outputString, "WB2OSZ-15")
	// assert.Contains(t, outputString, "The quick brown fox jumps over the lazy dog!")
	assert.Contains(t, outputString, "4 packets decoded")
}

// buildWAVWithExtraChunks constructs a minimal valid mono 8-bit PCM WAV file
// whose RIFF body contains:
//
//   - an odd-sized JUNK chunk before "fmt " (exercises chunk-skip + odd padding)
//   - a "fmt " chunk
//   - an even-sized LIST chunk between "fmt " and "data" (exercises chunk-skip)
//   - a "data" chunk with silent PCM samples
func buildWAVWithExtraChunks(t *testing.T) []byte {
	t.Helper()

	var body bytes.Buffer

	writeChunk := func(id string, payload []byte) {
		body.WriteString(id)
		binary.Write(&body, binary.LittleEndian, int32(len(payload))) //nolint:errcheck
		body.Write(payload)

		if len(payload)%2 != 0 {
			body.WriteByte(0) // RIFF word-alignment pad
		}
	}

	// Odd-sized extra chunk before "fmt ": Datasize=3 forces the seek to
	// advance by 3+1=4 bytes so the next chunk header is aligned.
	writeChunk("JUNK", make([]byte, 3))

	// "fmt " chunk â€” 16-byte PCM descriptor.
	var fmtPayload bytes.Buffer
	binary.Write(&fmtPayload, binary.LittleEndian, int16(1))    //nolint:errcheck // PCM
	binary.Write(&fmtPayload, binary.LittleEndian, int16(1))    //nolint:errcheck // mono
	binary.Write(&fmtPayload, binary.LittleEndian, int32(8000)) //nolint:errcheck // 8 kHz
	binary.Write(&fmtPayload, binary.LittleEndian, int32(8000)) //nolint:errcheck // avg bytes/sec
	binary.Write(&fmtPayload, binary.LittleEndian, int16(1))    //nolint:errcheck // block align
	binary.Write(&fmtPayload, binary.LittleEndian, int16(8))    //nolint:errcheck // 8 bits/sample
	writeChunk("fmt ", fmtPayload.Bytes())

	// Even-sized extra chunk between "fmt " and "data".
	writeChunk("LIST", make([]byte, 4))

	// Minimal silent PCM audio (0.1 s at 8 kHz).
	writeChunk("data", make([]byte, 800))

	var wav bytes.Buffer
	wav.WriteString("RIFF")
	binary.Write(&wav, binary.LittleEndian, int32(4+body.Len())) //nolint:errcheck
	wav.WriteString("WAVE")
	wav.Write(body.Bytes())

	return wav.Bytes()
}

// Test_atest_extraChunks verifies that the WAV parser correctly skips
// arbitrary metadata chunks (before "fmt " and between "fmt " and "data")
// and successfully decodes a file containing such chunks.
func Test_atest_extraChunks(t *testing.T) {
	// AtestMain registers flags on pflag.CommandLine; reset it so this test
	// can run independently of Test_atest_basic_1.
	pflag.CommandLine = pflag.NewFlagSet(os.Args[0], pflag.ExitOnError)

	var tmpdir = t.TempDir()

	var f = filepath.Join(tmpdir, "extra_chunks.wav")

	var err = os.WriteFile(f, buildWAVWithExtraChunks(t), 0600)
	require.NoError(t, err)

	os.Args = []string{"atest", f}

	var oldStdout = os.Stdout

	defer func() {
		os.Stdout = oldStdout
	}()

	var r, w, _ = os.Pipe()

	os.Stdout = w

	AtestMain()

	w.Close() //nolint:gosec

	os.Stdout = oldStdout

	var outputBytes, _ = io.ReadAll(r)

	assert.Contains(t, string(outputBytes), "0 packets decoded")
}
