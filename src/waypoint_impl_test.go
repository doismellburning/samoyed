package direwolf

// KG 2026-02-22 These tests were generated by Claude based on waypoint.go
// and as such it's very much a test of the implementation as-is.
// A failing test may thus be a problem with the test itself rather than any future changes...

import (
	"fmt"
	"net"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// computeChecksum calculates the NMEA XOR checksum for a sentence beginning with '$'.
func computeChecksum(sentence string) int {
	var cs = 0
	for _, c := range sentence[1:] {
		cs ^= int(c)
	}
	return cs & 0xff
}

// TestAppendChecksumBasic tests simple known inputs.
func TestAppendChecksumBasic(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "single char after dollar",
			input:    "$A",
			expected: "$A*41",
		},
		{
			name:     "two chars",
			input:    "$AB",
			expected: "$AB*03",
		},
		{
			name:     "GPWPL prefix only",
			input:    "$GPWPL",
			expected: "$GPWPL*5C",
		},
		{
			name:     "PKWDWPL prefix only",
			input:    "$PKWDWPL",
			expected: "$PKWDWPL*43",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var result = append_checksum([]byte(tt.input))
			assert.Equal(t, tt.expected, string(result))
		})
	}
}

// TestAppendChecksumFormat verifies the output always ends with *XX.
func TestAppendChecksumFormat(t *testing.T) {
	var inputs = []string{
		"$GPWPL,4221.6060,N,07120.8300,W,TEST",
		"$PKWDWPL,150803,V,4237.14,N,07120.83,W,,,190316,,test,/'",
		"$PMGNWPL,4237.1400,N,07120.8300,W,,M,TEST,,T",
	}

	for _, input := range inputs {
		t.Run(input[:8], func(t *testing.T) {
			var result = string(append_checksum([]byte(input)))

			// Must preserve original sentence.
			assert.True(t, strings.HasPrefix(result, input),
				"result should start with original sentence")

			// Must end with *HH where H is an uppercase hex digit.
			require.Greater(t, len(result), len(input)+2,
				"result should be longer than input")
			assert.Equal(t, '*', rune(result[len(input)]),
				"separator must be *")

			var hexPart = result[len(input)+1:]
			assert.Len(t, hexPart, 2, "checksum must be exactly two hex digits")
			for _, c := range hexPart {
				assert.True(t, (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F'),
					"checksum digits must be uppercase hex")
			}
		})
	}
}

// TestAppendChecksumCorrectness verifies the checksum value is correct.
func TestAppendChecksumCorrectness(t *testing.T) {
	var inputs = []string{
		"$GPWPL,0000.0000,N,00000.0000,E,WPT1",
		"$PGRMW,TEST,100.0,0041,hello",
		"$PMGNWPL,4237.1400,N,07120.8300,W,100.0,M,MYOBJ,comment,T",
		"$PKWDWPL,120000,V,4237.1400,N,07120.8300,W,0.0,0.0,010124,100.0,CALL,/'",
	}

	for _, input := range inputs {
		t.Run(input[:8], func(t *testing.T) {
			var result = string(append_checksum([]byte(input)))
			var expected = computeChecksum(input)
			var actual = 0
			_, err := fmt.Sscanf(result[len(result)-2:], "%X", &actual)
			require.NoError(t, err)
			assert.Equal(t, expected, actual, "checksum value should match XOR computation")
		})
	}
}

// TestAppendChecksumIdempotentInput verifies the input slice is not modified in place.
func TestAppendChecksumIdempotentInput(t *testing.T) {
	var input = []byte("$GPWPL,test")
	var original = string(input)
	var result = append_checksum(input)
	assert.Equal(t, original, string(input), "original slice content must not change")
	assert.True(t, strings.HasPrefix(string(result), original),
		"result must start with original content")
}

// udpPort returns the port number from a PacketConn bound to a UDP address.
func udpPort(t *testing.T, conn net.PacketConn) int {
	t.Helper()
	addr, ok := conn.LocalAddr().(*net.UDPAddr)
	require.True(t, ok, "listener must be bound to a UDP address")
	return addr.Port
}

// receiveUDP reads one datagram from conn with a 2-second deadline.
func receiveUDP(t *testing.T, conn net.PacketConn) string {
	t.Helper()
	err := conn.SetReadDeadline(time.Now().Add(2 * time.Second))
	require.NoError(t, err)
	var buf = make([]byte, 4096)
	var n, _, readErr = conn.ReadFrom(buf)
	require.NoError(t, readErr, "should receive a UDP datagram")
	return string(buf[:n])
}

// setupUDPWaypoint starts a UDP listener and initialises the waypoint subsystem
// to send to it.  It returns a cleanup function that must be deferred.
func setupUDPWaypoint(t *testing.T, formats int) net.PacketConn {
	t.Helper()

	var listener, err = net.ListenPacket("udp", "127.0.0.1:0")
	require.NoError(t, err)

	var mc = misc_config_s{ //nolint: exhaustruct
		waypoint_udp_hostname: "127.0.0.1",
		waypoint_udp_portnum:  udpPort(t, listener),
		waypoint_formats:      formats,
	}
	waypoint_init(&mc)

	t.Cleanup(func() {
		waypoint_term()
		listener.Close() //nolint:gosec,errcheck
	})

	return listener
}

// TestWaypointSendSentenceNMEAGeneric verifies $GPWPL output over UDP.
func TestWaypointSendSentenceNMEAGeneric(t *testing.T) {
	var listener = setupUDPWaypoint(t, WPL_FORMAT_NMEA_GENERIC)

	waypoint_send_sentence("TEST", 42.0, -71.0, '/', 'a', G_UNKNOWN, G_UNKNOWN, G_UNKNOWN, "")

	var got = receiveUDP(t, listener)
	// Should contain exactly one CRLF-terminated NMEA sentence.
	assert.True(t, strings.HasPrefix(got, "$GPWPL,"), "should be a GPWPL sentence")
	assert.True(t, strings.HasSuffix(got, "\r\n"), "sentence must end with CRLF")

	// Strip CRLF and verify checksum.
	var sentence = strings.TrimRight(got, "\r\n")
	var starIdx = strings.LastIndex(sentence, "*")
	require.Positive(t, starIdx, "sentence must contain a checksum")
	var body = sentence[:starIdx]
	var expected = computeChecksum(body)
	var actual = 0
	_, scanErr := fmt.Sscanf(sentence[starIdx+1:], "%X", &actual)
	require.NoError(t, scanErr)
	assert.Equal(t, expected, actual, "GPWPL checksum should be correct")

	// Verify it contains the waypoint name.
	assert.Contains(t, sentence, "TEST", "sentence should contain the waypoint name")
}

// TestWaypointSendSentenceKenwood verifies $PKWDWPL output over UDP.
func TestWaypointSendSentenceKenwood(t *testing.T) {
	var listener = setupUDPWaypoint(t, WPL_FORMAT_KENWOOD)

	waypoint_send_sentence("W1AW", 41.7147, -72.7272, '/', '-', 100.0, 270.0, 10.0, "")

	var got = receiveUDP(t, listener)
	assert.True(t, strings.HasPrefix(got, "$PKWDWPL,"), "should be a PKWDWPL sentence")
	assert.True(t, strings.HasSuffix(got, "\r\n"), "sentence must end with CRLF")
	assert.Contains(t, got, "W1AW", "sentence should contain the waypoint name")
}

// TestWaypointSendSentenceMagellan verifies $PMGNWPL output over UDP.
func TestWaypointSendSentenceMagellan(t *testing.T) {
	var listener = setupUDPWaypoint(t, WPL_FORMAT_MAGELLAN)

	waypoint_send_sentence("MAGSTN", 34.0, -118.0, '/', '-', 50.0, G_UNKNOWN, G_UNKNOWN, "a comment")

	var got = receiveUDP(t, listener)
	assert.True(t, strings.HasPrefix(got, "$PMGNWPL,"), "should be a PMGNWPL sentence")
	assert.Contains(t, got, "MAGSTN", "sentence should contain the waypoint name")
	assert.Contains(t, got, "a comment", "sentence should contain the comment")
}

// TestWaypointSendSentenceNoDest verifies early return when no destination is configured.
func TestWaypointSendSentenceNoDest(t *testing.T) {
	// Ensure clean state: no serial port, no UDP socket.
	s_waypoint_serial_port_fd = nil
	s_waypoint_udp_sock = nil

	// Should not panic.
	waypoint_send_sentence("TEST", 42.0, -71.0, '/', 'a', G_UNKNOWN, G_UNKNOWN, G_UNKNOWN, "")
}

// TestWaypointSendSentenceCommaInName verifies comma substitution.
func TestWaypointSendSentenceCommaInName(t *testing.T) {
	var listener = setupUDPWaypoint(t, WPL_FORMAT_NMEA_GENERIC)

	waypoint_send_sentence("MY,OBJ", 42.0, -71.0, '/', '-', G_UNKNOWN, G_UNKNOWN, G_UNKNOWN, "")

	var got = receiveUDP(t, listener)
	assert.NotContains(t, got[:strings.LastIndex(got, "*")], ",MY,OBJ,",
		"raw comma in name should be substituted before the checksum field")
	assert.Contains(t, got, "MY|OBJ", "comma in name should become pipe character")
}

// TestWaypointSendSentenceAsteriskInName verifies asterisk substitution.
func TestWaypointSendSentenceAsteriskInName(t *testing.T) {
	var listener = setupUDPWaypoint(t, WPL_FORMAT_NMEA_GENERIC)

	waypoint_send_sentence("MY*OBJ", 42.0, -71.0, '/', '-', G_UNKNOWN, G_UNKNOWN, G_UNKNOWN, "")

	var got = receiveUDP(t, listener)
	assert.Contains(t, got, "MY~OBJ", "asterisk in name should become tilde character")
}

// TestWaypointSendSentenceKenwoodSymbolComma verifies Kenwood comma-symbol substitution.
func TestWaypointSendSentenceKenwoodSymbolComma(t *testing.T) {
	var listener = setupUDPWaypoint(t, WPL_FORMAT_KENWOOD)

	// Symbol ',' (Boy Scouts) should be substituted to '|'.
	waypoint_send_sentence("BSCOUT", 42.0, -71.0, '/', ',', G_UNKNOWN, G_UNKNOWN, G_UNKNOWN, "")

	var got = receiveUDP(t, listener)
	// The Kenwood sentence ends with two-char symbol (table + code).
	// Verify the body (before '*') doesn't contain an unescaped comma as the symbol.
	var body = got[:strings.LastIndex(got, "*")]
	var fields = strings.Split(body, ",")
	var last = fields[len(fields)-1]
	assert.Equal(t, "/|", last, "symbol comma should be replaced with pipe in Kenwood")
}

// TestWaypointSendAisNoDest verifies AIS early return when no destination configured.
func TestWaypointSendAisNoDest(t *testing.T) {
	s_waypoint_serial_port_fd = nil
	s_waypoint_udp_sock = nil

	// Should not panic.
	waypoint_send_ais([]byte("!AIVDM,1,1,,A,35NO=dPOiAJriVDH@94E84AJ0000,0*4B"))
}

// TestWaypointSendAisUDP verifies AIS sentences are forwarded over UDP.
func TestWaypointSendAisUDP(t *testing.T) {
	var listener = setupUDPWaypoint(t, WPL_FORMAT_AIS)

	var aisMsg = []byte("!AIVDM,1,1,,A,35NO=dPOiAJriVDH@94E84AJ0000,0*4B")
	waypoint_send_ais(aisMsg)

	var got = receiveUDP(t, listener)
	assert.True(t, strings.HasPrefix(got, "!AIVDM,"), "AIS sentence should be forwarded unchanged")
	assert.True(t, strings.HasSuffix(got, "\r\n"), "AIS sentence must end with CRLF")
	assert.Contains(t, got, "35NO=dPOiAJriVDH@94E84AJ0000", "AIS payload should be present")
}

// TestWaypointSendAisWrongFormat verifies AIS not sent when format flag not set.
func TestWaypointSendAisWrongFormat(t *testing.T) {
	var listener = setupUDPWaypoint(t, WPL_FORMAT_NMEA_GENERIC)

	waypoint_send_ais([]byte("!AIVDM,1,1,,A,35NO=dPOiAJriVDH@94E84AJ0000,0*4B"))

	// Listener should receive nothing; set a short deadline and expect a timeout.
	err := listener.SetReadDeadline(time.Now().Add(100 * time.Millisecond))
	require.NoError(t, err)
	var buf = make([]byte, 4096)
	var _, _, readErr = listener.ReadFrom(buf)
	assert.Error(t, readErr, "should timeout because AIS flag is not set")
}

// TestWaypointDefaultFormats verifies that init sets defaults when formats==0.
func TestWaypointDefaultFormats(t *testing.T) {
	var listener, err = net.ListenPacket("udp", "127.0.0.1:0")
	require.NoError(t, err)
	t.Cleanup(func() {
		waypoint_term()
		listener.Close() //nolint:gosec,errcheck
	})

	var mc = misc_config_s{ //nolint: exhaustruct
		waypoint_udp_hostname: "127.0.0.1",
		waypoint_udp_portnum:  udpPort(t, listener),
		waypoint_formats:      0, // let init pick defaults
	}
	waypoint_init(&mc)

	assert.Equal(t, WPL_FORMAT_NMEA_GENERIC|WPL_FORMAT_KENWOOD, s_waypoint_formats,
		"default formats should be NMEA generic + Kenwood")
}

// TestWaypointGarminImpliesNMEAGeneric verifies Garmin format forces NMEA generic.
func TestWaypointGarminImpliesNMEAGeneric(t *testing.T) {
	var listener, err = net.ListenPacket("udp", "127.0.0.1:0")
	require.NoError(t, err)
	t.Cleanup(func() {
		waypoint_term()
		listener.Close() //nolint:gosec,errcheck
	})

	var mc = misc_config_s{ //nolint: exhaustruct
		waypoint_udp_hostname: "127.0.0.1",
		waypoint_udp_portnum:  udpPort(t, listener),
		waypoint_formats:      WPL_FORMAT_GARMIN,
	}
	waypoint_init(&mc)

	assert.NotZero(t, s_waypoint_formats&WPL_FORMAT_NMEA_GENERIC,
		"Garmin format should imply NMEA generic")
}

// TestWaypointTermClearsState verifies that waypoint_term resets the globals.
func TestWaypointTermClearsState(t *testing.T) {
	var listener, err = net.ListenPacket("udp", "127.0.0.1:0")
	require.NoError(t, err)
	t.Cleanup(func() {
		listener.Close() //nolint:gosec,errcheck
	})

	var mc = misc_config_s{ //nolint: exhaustruct
		waypoint_udp_hostname: "127.0.0.1",
		waypoint_udp_portnum:  udpPort(t, listener),
		waypoint_formats:      WPL_FORMAT_KENWOOD,
	}
	waypoint_init(&mc)
	require.NotNil(t, s_waypoint_udp_sock, "socket should be open after init")

	waypoint_term()
	assert.Nil(t, s_waypoint_udp_sock, "socket should be nil after term")
	assert.Nil(t, s_waypoint_serial_port_fd, "serial port fd should be nil after term")
}
